{"pages":[{"title":"about","text":"æ•´ç†ä¸€äº›æ—¥å¸¸æ€è€ƒï¼ŒåŒæ—¶å½“å·¥å…·å¯¼èˆªç½‘ç«™ç”¨ã€‚ ä¸å®šæœŸæ›´æ–°ã€‚","link":"/about/index.html"},{"title":"links","text":"Here are some useful linksMath and PhysicsLinear AlgebraCalculusProgrammingGit CommandsConda CommandsMarkDownMusicChordsè¯—æ­Œå¹³ä¸Šå»å…¥è¡¨Other Blogs","link":"/links/index.html"}],"posts":[{"title":"Bitcoin Price Prediction Project","text":"ä½¿ç”¨æœºå™¨å­¦ä¹ æŠ€æœ¯ï¼Œé¢„æµ‹çŸ­æœŸèµ°åŠ¿ã€‚æ¯”ç‰¹å¸åªæ˜¯ä¸€ä¸ªæ¡ˆä¾‹ï¼Œç†è®ºä¸Šå¯ä»¥é¢„æµ‹ä»»ä½•æ—¶é—´åºåˆ—ã€‚å‡†ä¸å‡†å°±æ˜¯å¦å¤–ä¸€å›äº‹äº†ã€‚ è¯¦ç»†ä»‹ç»ç­‰æœ‰ç©ºäº†å†å†™ã€‚ ä»£ç ï¼š Datasource.py import requests import pandas as pd import time from datetime import datetime, timedelta import pytz import matplotlib.pyplot as plt BASE_URL = &quot;https://api.binance.com/api/v3/klines&quot; CET = pytz.timezone(&quot;Europe/Paris&quot;) # Central European Time def get_binance_ohlcv(symbol='BTCUSDT', interval='5m', limit=1000, start_time=None): &quot;&quot;&quot; Fetch OHLCV data from Binance starting at `start_time`. &quot;&quot;&quot; url = BASE_URL params = { 'symbol': symbol, 'interval': interval, 'limit': limit, } if start_time: params['startTime'] = start_time response = requests.get(url, params=params) data = response.json() if not isinstance(data, list): print(&quot;Error fetching:&quot;, data) return pd.DataFrame() df = pd.DataFrame(data, columns=[ 'timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_volume', 'taker_buy_quote_volume', 'ignore' ]) df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms') df.set_index('timestamp', inplace=True) df = df.astype({ 'open': 'float', 'high': 'float', 'low': 'float', 'close': 'float', 'volume': 'float' }) return df[['open', 'high', 'low', 'close', 'volume']] def fetch_full_history(symbol='BTCUSDT', interval='5m', save_every=50): &quot;&quot;&quot; Fetch all historical data since 2017 in chunks of 1000 rows. &quot;&quot;&quot; full_df = pd.DataFrame() start_time = int(datetime(2017, 7, 1).timestamp() * 1000) now = int(datetime.now().timestamp() * 1000) counter = 0 while start_time &lt; now: df = get_binance_ohlcv(symbol=symbol, interval=interval, start_time=start_time) if df.empty: break full_df = pd.concat([full_df, df]) start_time = int(df.index[-1].timestamp() * 1000) + 1 # next candle counter += 1 print(f&quot;Fetched window {counter}: {df.index[0]} to {df.index[-1]}, total rows: {len(full_df)}&quot;) # Optional: Save interim files if counter % save_every == 0: filename = f&quot;btc_5min_partial_{counter}.xlsx&quot; #full_df.to_excel(filename) print(f&quot;Saved partial data to {filename}&quot;) time.sleep(0.4) # throttle to avoid rate limiting return full_df if __name__ == &quot;__main__&quot;: #df = fetch_full_history() #df.to_excel(&quot;btc_5min_full.xlsx&quot;) df = &quot;btc_5min_full.xlsx&quot; df = pd.read_excel(df, index_col=0, parse_dates=True) print(&quot;Saved full dataset to btc_5min_full.xlsx&quot;) # Plot plt.figure(figsize=(14, 6)) df['close'].plot(title=&quot;BTC/USDT - 5 Minute Closing Price (Since 2017)&quot;, grid=True) plt.xlabel(&quot;Time (CET)&quot;) plt.ylabel(&quot;Price (USDT)&quot;) plt.tight_layout() plt.savefig(&quot;btc_price_full_plot.png&quot;) plt.show() æ•°æ®æ”¶é›† Preprocess.py import pandas as pd import numpy as np from sklearn.preprocessing import MinMaxScaler from ta.momentum import RSIIndicator from ta.trend import MACD from ta.volatility import BollingerBands RAW_DATA_FILE = &quot;btc_5min_full.xlsx&quot; PROCESSED_DATA_FILE = &quot;btc_processed.pkl&quot; def load_and_prepare_data(file_path=RAW_DATA_FILE): df = pd.read_excel(file_path, index_col=0, parse_dates=True) # Ensure the index is sorted and cleaned df.sort_index(inplace=True) df = df[~df.index.duplicated(keep='first')] return df def preprocess_data(df, resample_interval=None): # Optional resample if resample_interval: df = df.resample(resample_interval).agg({ 'open': 'first', 'high': 'max', 'low': 'min', 'close': 'last', 'volume': 'sum' }).dropna() # Handle missing values (forward fill) df.ffill(inplace=True) # Normalize price and volume scaler = MinMaxScaler() df[['open', 'high', 'low', 'close', 'volume']] = scaler.fit_transform(df[['open', 'high', 'low', 'close', 'volume']]) # Create lag features (1, 2, 3 steps back) for lag in [1, 2, 3]: df[f'close_lag_{lag}'] = df['close'].shift(lag) # Technical indicators df['rsi'] = RSIIndicator(close=df['close'], window=14).rsi() df['macd'] = MACD(close=df['close']).macd() bb = BollingerBands(close=df['close'], window=20, window_dev=2) df['bb_upper'] = bb.bollinger_hband() df['bb_lower'] = bb.bollinger_lband() # Drop rows with NaNs from indicator calculations df.dropna(inplace=True) return df, scaler def save_processed_data(df, path=PROCESSED_DATA_FILE): df.to_pickle(path) print(f&quot;âœ… Preprocessed data saved to {path}&quot;) def main(): df_raw = load_and_prepare_data() df_processed, _ = preprocess_data(df_raw) save_processed_data(df_processed) if __name__ == &quot;__main__&quot;: main() print(&quot;âœ… Preprocessing complete!&quot;) æ•°æ®é¢„å¤„ç† Model.py import pandas as pd import numpy as np import xgboost as xgb from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score import matplotlib.pyplot as plt import joblib import os DATA_PATH = &quot;btc_processed.pkl&quot; MODEL_SAVE_PATH = &quot;xgb_model.pkl&quot; # Helper to add temporal features def add_time_features(df): df['hour'] = df.index.hour df['dayofweek'] = df.index.dayofweek return df # Add rolling features def add_rolling_features(df): df['rolling_std_12'] = df['close'].rolling(window=12).std() df['rolling_return_12'] = df['close'].pct_change(periods=12) return df def walk_forward_validation(df, window_size=10000, horizon=288): errors = [] predictions = [] actuals = [] timestamps = [] i = 0 while i + window_size + horizon &lt; len(df): train = df.iloc[i:i + window_size].copy() test = df.iloc[i + window_size:i + window_size + horizon].copy() X_train = train.drop(['close'], axis=1) y_train = train['close'] X_test = test.drop(['close'], axis=1) y_test = test['close'] # Remove any potential inf or NaN values X_train.replace([np.inf, -np.inf], np.nan, inplace=True) X_test.replace([np.inf, -np.inf], np.nan, inplace=True) X_train.dropna(inplace=True) X_test.dropna(inplace=True) y_train = y_train.loc[X_train.index] y_test = y_test.loc[X_test.index] model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, max_depth=6, learning_rate=0.05) model.fit(X_train, y_train) # Save model and features joblib.dump(model, &quot;xgb_model.pkl&quot;) joblib.dump(X_train.columns.tolist(), &quot;feature_list.pkl&quot;) # ğŸ‘ˆ Save feature list y_pred = model.predict(X_test) predictions.extend(y_pred) actuals.extend(y_test) timestamps.extend(X_test.index) rmse = np.sqrt(mean_squared_error(y_test, y_pred)) mae = mean_absolute_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) errors.append((rmse, mae, r2)) print(f&quot;Window {i // horizon}: RMSE={rmse:.6f}, MAE={mae:.6f}, R2={r2:.6f}&quot;) i += horizon return predictions, actuals, timestamps, errors, model def main(): df = pd.read_pickle(DATA_PATH) df = add_time_features(df) df = add_rolling_features(df) df.replace([np.inf, -np.inf], np.nan, inplace=True) df.dropna(inplace=True) y = df['close'].copy() X = df.drop(columns=['close']) df_full = df.copy() preds, actuals, times, errors, final_model = walk_forward_validation(df_full) # Save final model joblib.dump(final_model, MODEL_SAVE_PATH) print(f&quot;\\nModel saved to {MODEL_SAVE_PATH}&quot;) # Convert to series pred_series = pd.Series(preds, index=times) actual_series = pd.Series(actuals, index=times) # Plot plt.figure(figsize=(14, 6)) plt.plot(actual_series, label=&quot;Actual&quot;) plt.plot(pred_series, label=&quot;Predicted&quot;) plt.title(&quot;Predicted vs Actual BTC Price (Walk-forward)&quot;) plt.legend() plt.grid() plt.tight_layout() plt.savefig(&quot;btc_pred_vs_actual.png&quot;) plt.show() # Metrics summary errors = np.array(errors) print(f&quot;\\nAverage RMSE: {errors[:, 0].mean():.6f}&quot;) print(f&quot;Average MAE: {errors[:, 1].mean():.6f}&quot;) print(f&quot;Average R2: {errors[:, 2].mean():.6f}&quot;) if __name__ == &quot;__main__&quot;: main() æ¨¡å‹è®­ç»ƒ Prediction.py import pandas as pd import numpy as np import joblib import matplotlib.pyplot as plt from sklearn.preprocessing import MinMaxScaler from model import add_time_features, add_rolling_features from ta.momentum import RSIIndicator from ta.trend import MACD from ta.volatility import BollingerBands DATA_PATH = &quot;btc_processed.pkl&quot; MODEL_PATH = &quot;xgb_model.pkl&quot; FEATURES_PATH = &quot;feature_list.pkl&quot; SCALER_PATH = &quot;btc_scaler.pkl&quot; # Optional if you saved it separately FUTURE_STEPS = 1000 # number of future steps to forecast (e.g., 12 x 5min = 1 hour) INTERVAL_MINUTES = 5 print(&quot;ğŸ”„ Loading model and data...&quot;) # Load data and model df = pd.read_pickle(DATA_PATH) model = joblib.load(MODEL_PATH) feature_list = joblib.load(FEATURES_PATH) # Extract last known values for forecasting df_live = df.copy() scaler = MinMaxScaler() df_live[['open', 'high', 'low', 'close', 'volume']] = scaler.fit_transform(df_live[['open', 'high', 'low', 'close', 'volume']]) print(f&quot;ğŸ”® Predicting {FUTURE_STEPS} steps into the future...&quot;) future_preds = [] future_times = [] for step in range(FUTURE_STEPS): print(f&quot;ğŸ” Step {step}: df_live shape = {df_live.shape}&quot;) # Create one row of future timestamp last_timestamp = df_live.index[-1] next_timestamp = last_timestamp + pd.Timedelta(minutes=INTERVAL_MINUTES) new_row = df_live.iloc[-1].copy() new_row.name = next_timestamp df_live = pd.concat([df_live, pd.DataFrame([new_row])]) # Apply feature engineering df_extended = df_live.copy() df_extended = add_time_features(df_extended) df_extended = add_rolling_features(df_extended) df_extended['rsi'] = RSIIndicator(close=df_extended['close'], window=14).rsi() df_extended['macd'] = MACD(close=df_extended['close']).macd() bb = BollingerBands(close=df_extended['close'], window=20, window_dev=2) df_extended['bb_upper'] = bb.bollinger_hband() df_extended['bb_lower'] = bb.bollinger_lband() df_extended.replace([np.inf, -np.inf], np.nan, inplace=True) df_extended.dropna(inplace=True) if df_extended.empty: print(f&quot;âš ï¸ Step {step}: No data after feature engineering. Stopping forecast.&quot;) break X_latest = df_extended[feature_list].iloc[[-1]] y_pred = model.predict(X_latest)[0] future_preds.append(y_pred) future_times.append(next_timestamp) # Update 'close' in df_live with the prediction for next iteration df_live.loc[next_timestamp, 'close'] = y_pred # Convert predictions back to original scale (denormalize) # Use inverse_transform on 'close' column only close_min = scaler.data_min_[3] # 'close' is the 4th column (index 3) close_max = scaler.data_max_[3] denorm_preds = [pred * (close_max - close_min) + close_min for pred in future_preds] pred_series = pd.Series(denorm_preds, index=pd.DatetimeIndex(future_times)) print(&quot;\\nâœ… Forecast complete. Here are the next predicted values:&quot;) print(pred_series) # Plot results plt.figure(figsize=(12, 5)) pred_series.plot(label=&quot;Predicted Close&quot;, color='orange') plt.title(&quot;Future BTC Price Forecast&quot;) plt.xlabel(&quot;Time&quot;) plt.ylabel(&quot;Price (USDT)&quot;) plt.grid() plt.legend() plt.tight_layout() plt.savefig(&quot;btc_future_forecast.png&quot;) plt.show() é¢„æµ‹","link":"/2025/06/16/Bitcoin-Price-Prediction-Project/"},{"title":"F-Voice Evolution Simulation","text":"æˆ‘ä»¬éƒ½çŸ¥é“ç”·æ€§åœ¨é’æ˜¥æœŸä¹‹åå£°éŸ³ä¼šå˜ä½æ²‰ï¼ˆé¢‘ç‡å˜ä½ï¼‰ï¼Œä½†æ˜¯æˆå¹´å¥³æ€§ä¸å°å­©çš„å£°éŸ³éƒ½æ˜¯é«˜é¢‘ï¼Œå¯æ˜¯ä¸¤è€…ä¹‹é—´æ˜¯å¦æœ‰æ˜æ˜¾åŒºåˆ«ï¼Ÿè¿™ä¸ªé¡¹ç›®å°†é€šè¿‡æ¨¡æ‹Ÿè¯•å›¾å›ç­”è¿™ä¸ªé—®é¢˜ã€‚ code: ç”ŸæˆéŸ³é¢‘ from gtts import gTTS from pydub import AudioSegment from pydub.playback import play import os import numpy as np # è®¾ç½®è¾“å‡ºç›®å½• output_dir = &quot;female_voice_evolution&quot; os.makedirs(output_dir, exist_ok=True) # å¹´é¾„èŒƒå›´ï¼ˆ10 åˆ° 32 å²ï¼Œæ¯éš”2å²ï¼‰ ages = list(range(10, 34, 2)) # ä¸­æ–‡å¥å­æ¨¡æ¿ template = &quot;ä½ å¥½ï¼Œæˆ‘å«å°æã€‚ä»Šå¹´{}å²ï¼Œå¾ˆé«˜å…´è®¤è¯†ä½ ã€‚&quot; # éŸ³è°ƒå’Œé€Ÿåº¦çš„æ¨¡æ‹Ÿå‡½æ•°ï¼ˆé€šè¿‡å¹´é¾„æ˜ å°„ï¼‰ def change_pitch_and_speed(sound, age): # æ¨¡æ‹ŸéŸ³è°ƒå˜åŒ–ï¼ˆ10å²é«˜éŸ³ï¼Œ32å²ä½éŸ³ï¼‰ # ä»¥12å²ä¸ºåŸºå‡†ï¼ŒéŸ³è°ƒæ¯å¹´é™ä½0.5%ï¼Œé€Ÿåº¦æ¯å¹´é™ä½0.3% pitch_shift = 1.2 - ((age - 10) * 0.015) # æ¯”å¦‚ï¼š10å²æ˜¯1.2å€é¢‘ç‡ï¼Œ32å²æ˜¯0.84å€ speed_change = 1.1 - ((age - 10) * 0.01) # æ¯”å¦‚ï¼š10å²è¯­é€Ÿå¿«ï¼Œ32å²æ…¢ä¸€äº› # æ”¹å˜é€Ÿåº¦ sound = sound._spawn(sound.raw_data, overrides={ &quot;frame_rate&quot;: int(sound.frame_rate * speed_change) }).set_frame_rate(sound.frame_rate) # æ”¹å˜éŸ³è°ƒï¼ˆæ”¹å˜é‡‡æ ·ç‡æ¨¡æ‹Ÿpitchï¼‰ sound = sound._spawn(sound.raw_data, overrides={ &quot;frame_rate&quot;: int(sound.frame_rate * pitch_shift) }).set_frame_rate(22050) return sound # ç”Ÿæˆå¹¶ä¿å­˜æ¯ä¸ªå¹´é¾„çš„éŸ³é¢‘æ ·æœ¬ for age in ages: text = template.format(age) tts = gTTS(text=text, lang='zh-cn') temp_path = os.path.join(output_dir, f&quot;temp_{age}.mp3&quot;) tts.save(temp_path) # åŠ è½½éŸ³é¢‘ sound = AudioSegment.from_file(temp_path) # æ¨¡æ‹ŸéŸ³è°ƒ/è¯­é€Ÿå˜åŒ– processed = change_pitch_and_speed(sound, age) # è¾“å‡ºæ–‡ä»¶ final_path = os.path.join(output_dir, f&quot;xiaoli_{age}years_old.mp3&quot;) processed.export(final_path, format=&quot;mp3&quot;) print(f&quot;ç”Ÿæˆï¼š{final_path}&quot;) # åˆ é™¤ä¸­é—´æ–‡ä»¶ os.remove(temp_path) åˆæˆéŸ³è½¨ from pydub import AudioSegment import os # è¾“å…¥ç›®å½•ï¼ˆä½ ä¹‹å‰ä¿å­˜çš„éŸ³é¢‘ï¼‰ input_dir = &quot;female_voice_evolution&quot; output_file = &quot;xiao_li_voice_evolution_combined.mp3&quot; # è·å–æ‰€æœ‰éŸ³é¢‘æ–‡ä»¶ï¼ŒæŒ‰å¹´é¾„é¡ºåºæ’åº audio_files = sorted([ f for f in os.listdir(input_dir) if f.endswith(&quot;.mp3&quot;) and f.startswith(&quot;xiaoli_&quot;) ], key=lambda x: int(x.split(&quot;_&quot;)[1].replace(&quot;years&quot;, &quot;&quot;).replace(&quot;old.mp3&quot;, &quot;&quot;))) # åˆ›å»ºä¸€ä¸ªç©ºéŸ³è½¨ combined = AudioSegment.empty() # 1 ç§’é™éŸ³é—´éš” silence = AudioSegment.silent(duration=1000) # ä¾æ¬¡æ‹¼æ¥æ‰€æœ‰éŸ³é¢‘æ–‡ä»¶ for file in audio_files: path = os.path.join(input_dir, file) audio = AudioSegment.from_file(path) combined += audio + silence # å¯¼å‡ºæœ€ç»ˆåˆæˆéŸ³è½¨ combined.export(output_file, format=&quot;mp3&quot;) print(f&quot;åˆæˆéŸ³è½¨å·²ä¿å­˜ä¸ºï¼š{output_file}&quot;)","link":"/2025/06/16/F-Voice-Evolution-Simulation/"},{"title":"city night","text":"æ–‡åŒ–ç ”ç©¶å®è·µè¯¾ç¨‹è€ƒå¯Ÿå¤œæ¸¸(å›¾ç‰‡æœ‰ç‚¹å¤šï¼Œæƒ³çœ‹å¯ä»¥å…ˆæŒ‚ç€) å‡ºå‘å•¦ï¼Œ10ï¼š00ï¼Œæ ¡é—¨å£ åœ°é“ï¼Œè¿é¢èµ°æ¥çš„å¿«ä¹çš„äºº ä¸€ä¸ªäººçš„åŸå¸‚ ç‰å…°èŠ±é¦™ å¾·åŸºä¸‹ç­å‘˜å·¥ åå°„ æŸå¤§å¦ é¸Ÿç°å—äº¬ æ— é™åŸ æœ€å®‰é™çš„é…’å§ï¼Œæ²¡äººè¯´è¯ DJå°å§å§ å†æ¬¡å›åˆ°é©¬è·¯ä¸Šï¼Œå‡Œæ™¨ è·¯ä¸Šå¥‡æ€ªçš„å°åŒº å—äº¬æœ€å¤§çš„é…’å§ å…¥å£æ˜¯æ˜Ÿæ˜Ÿèµ°å»Šå’Œç¡•å¤§çš„è”·è–‡ é…’å§è¾¹å“äººçš„æ¸¸ä¹åœºï¼Œå¥‡æ€ªçš„ç©ºé—´å™äº‹ ä¸å¤œåŸï¼ˆå…¶å®ä¸¤ç‚¹å°±èµ¶äººå•¦ï¼‰ å¥¹ä»¬ååœ¨è¿™é‡Œï¼Œä¸å¤ªå¼€å¿ƒ é•œå¤´æ™ƒå¾—å¦™ é…’åçš„å°‘å¹´ ä¸‰ç‚¹è¿”æ ¡","link":"/2023/05/03/city-night/"},{"title":"è¯—è¯åˆ›ä½œ","text":"ä¸€ç§å³å…´çš„è€æ´¾æ–‡å­¦æ ·å¼ äº”è¨€ç»å¥å¹³èµ·é¦–æŠ¼å½’å¯º é£éœæ›²ç²‰é¦™ï¼Œæ´ç«¹ç»­æ±Ÿæ¢ã€‚æœˆåˆ¹æ‚²è¯å²ï¼Œå½’è¡£ç•é›¨é•¿ã€‚ ä»„èµ·é¦–æŠ¼æ‚²æ€ª æ—¥ç€‘æ¶é£é’Ÿï¼Œè¥¿å°æ›™æ€ªç¬¼ã€‚æ˜åŒ»ç¾å››æµ·ï¼Œæ°´èµ·å°”é¥¥å†¬ã€‚ å¹³èµ·é¦–ä¸æŠ¼ä»²ç§‹ çƒŸé˜³å‡‰ç±³å¸‚ï¼Œè‹¦é›¨çˆ±è¿Ÿæã€‚æœ¨é›ªè¿˜æ²™é¹„ï¼Œæ¸¸èˆŸé‡‡ä»²ç§‹ã€‚ ä»„èµ·é¦–ä¸æŠ¼ äº”è¨€å¾‹è¯—ä¸ƒè¨€ç»å¥å¹³èµ·é¦–æŠ¼ç”°å›­å³å…´ æ˜¥è‹”è±†æ‰‡ç¾¡ç”°æ¡¥ï¼Œé†‰è‡³å±±é—´æˆå¥³è§ã€‚å¯å…¥çœ æ³‰æ€€åŒ—è°ƒï¼Œæ‘å·¾é£æ›²å”¤é’è‹—ã€‚ ä»„èµ·é¦–æŠ¼å¤œå…¥å¯’å±± é›ªè½ç©ºå±±åŠå®¢è¿Ÿï¼Œè½»åŸé…’æš–éª—ä½³è¯—ã€‚é¥é¥å†°æœˆå¹³å¤©ä¸¾ï¼Œçƒ›é‡Œé£è›¾ä¼´å¾ç—´ã€‚ ä¸ƒè¨€å¾‹è¯— ä¸ƒè¨€å¾‹è©©æ­£æ ¼ï¼š 1ã€å¹³èµ·é¦–å¥å…¥éŸ»å¼ï¼ˆå¹³èµ·ï¼ŒæŒ‡ç¬¬ä¸€å€‹éŸ³ç¯€æ˜¯å¹³è²ï¼›é¦–å¥å…¥éŸ»ï¼ŒæŒ‡ç¬¬ä¸€å¥å¥æœ«æŠ¼éŸ»ã€‚ä¸‹åŒï¼‰ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ï¼Œï¼ˆéŸ»ï¼‰ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³å¹³ä»„ä»„ï¼Œ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»å¹³å¹³ä»„ä»„å¹³å¹³ä»„ï¼Œ ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³å¹³ä»„ä»„ï¼Œ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ» 2ã€å¹³èµ·é¦–å¥ä¸å…¥éŸ»å¼ï¼š å¹³å¹³ä»„ä»„å¹³å¹³ä»„ï¼Œ ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³å¹³ä»„ä»„ï¼Œ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»å¹³å¹³ä»„ä»„å¹³å¹³ä»„ï¼Œ ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³å¹³ä»„ä»„ï¼Œ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ» 3ã€ä»„èµ·é¦–å¥å…¥éŸ»å¼ï¼š ä»„ä»„å¹³å¹³ä»„ä»„å¹³ï¼Œï¼ˆéŸ»ï¼‰å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»å¹³å¹³ä»„ä»„å¹³å¹³ä»„ï¼Œ ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³å¹³ä»„ä»„ï¼Œ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»å¹³å¹³ä»„ä»„å¹³å¹³ä»„ï¼Œ ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ» 4ã€ä»„èµ·é¦–å¥ä¸å…¥éŸ»å¼ï¼š ä»„ä»„å¹³å¹³å¹³ä»„ä»„ï¼Œ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»å¹³å¹³ä»„ä»„å¹³å¹³ä»„ï¼Œ ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³å¹³ä»„ä»„ï¼Œ å¹³å¹³ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»å¹³å¹³ä»„ä»„å¹³å¹³ä»„ï¼Œ ä»„ä»„å¹³å¹³ä»„ä»„å¹³ã€‚éŸ» äº”è¨€å¾‹è©©æ­£æ ¼ï¼š 1ã€ä»„èµ·é¦–å¥å…¥éŸ»å¼ï¼ˆä»„èµ·ï¼ŒæŒ‡ç¬¬ä¸€å€‹éŸ³ç¯€æ˜¯ä»„è²ï¼›é¦–å¥å…¥éŸ»ï¼ŒæŒ‡ç¬¬ä¸€å¥å¥æœ«æŠ¼éŸ»ã€‚ä¸‹åŒï¼‰ ä»„ä»„ä»„å¹³å¹³ï¼Œï¼ˆéŸ»ï¼‰ å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»å¹³å¹³å¹³ä»„ä»„ï¼Œä»„ä»„ä»„å¹³å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³ä»„ï¼Œå¹³å¹³ä»„ä»„å¹³ã€‚éŸ»å¹³å¹³å¹³ä»„ä»„ï¼Œä»„ä»„ä»„å¹³å¹³ã€‚éŸ» 2ã€ä»„èµ·é¦–å¥ä¸å…¥éŸ»å¼ï¼š ä»„ä»„å¹³å¹³ä»„ï¼Œ å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»å¹³å¹³å¹³ä»„ä»„ï¼Œ ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³ä»„ï¼Œ å¹³å¹³ä»„ä»„å¹³ã€‚éŸ»å¹³å¹³å¹³ä»„ä»„ï¼Œ ä»„ä»„ä»„å¹³å¹³ã€‚éŸ» 3ã€å¹³èµ·é¦–å¥å…¥éŸ»å¼ï¼š å¹³å¹³ä»„ä»„å¹³ï¼Œï¼ˆéŸ»ï¼‰ ä»„ä»„ä»„å¹³å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³ä»„ï¼Œå¹³å¹³ä»„ä»„å¹³ã€‚éŸ»å¹³å¹³å¹³ä»„ä»„ï¼Œä»„ä»„ä»„å¹³å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³ä»„ï¼Œå¹³å¹³ä»„ä»„å¹³ã€‚éŸ» 4ã€å¹³èµ·é¦–å¥ä¸å…¥éŸ»å¼ï¼š å¹³å¹³å¹³ä»„ä»„ï¼Œä»„ä»„ä»„å¹³å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³ä»„ï¼Œå¹³å¹³ä»„ä»„å¹³ã€‚éŸ»å¹³å¹³å¹³ä»„ä»„ï¼Œä»„ä»„ä»„å¹³å¹³ã€‚éŸ»ä»„ä»„å¹³å¹³ä»„ï¼Œå¹³å¹³ä»„ä»„å¹³ã€‚éŸ» äº”è¨€ç»å¥ï¼Œå¹³èµ·å¼ï¼Œæ­£æ ¼ï¼š å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰ä»„ä»„å¹³å¹³ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰ äº”è¨€ç»å¥ï¼Œä»„èµ·å¼ï¼Œæ­£æ ¼ï¼š ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰å¹³å¹³å¹³ä»„ä»„ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰ äº”è¨€ç»å¥ï¼Œä»„èµ·å¼ï¼Œåæ ¼ï¼š ä»„ä»„å¹³å¹³ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰å¹³å¹³å¹³ä»„ä»„ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰ äº”è¨€ç»å¥ï¼Œå¹³èµ·å¼ï¼Œåæ ¼ï¼š å¹³å¹³å¹³ä»„ä»„ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰ä»„ä»„å¹³å¹³ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰ ä¸ƒè¨€ç»å¥ï¼Œä»„èµ·å¼ï¼Œæ­£æ ¼ï¼š ä»„ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰å¹³å¹³ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰å¹³å¹³ä»„ä»„å¹³å¹³ä»„ä»„ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰ ä¸ƒè¨€ç»å¥ï¼Œå¹³èµ·å¼ï¼Œæ­£æ ¼ï¼š å¹³å¹³ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰ä»„ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰ä»„ä»„å¹³å¹³å¹³ä»„ä»„å¹³å¹³ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰ ä¸ƒè¨€ç»å¥ï¼Œä»„èµ·å¼ï¼Œåæ ¼ï¼š ä»„ä»„å¹³å¹³å¹³ä»„ä»„å¹³å¹³ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰å¹³å¹³ä»„ä»„å¹³å¹³ä»„ä»„ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰ ä¸ƒè¨€ç»å¥ï¼Œå¹³èµ·å¼ï¼Œåæ ¼ï¼š å¹³å¹³ä»„ä»„å¹³å¹³ä»„ä»„ä»„å¹³å¹³ä»„ä»„å¹³ï¼ˆéŸµï¼‰ä»„ä»„å¹³å¹³å¹³ä»„ä»„å¹³å¹³ä»„ä»„ä»„å¹³å¹³ï¼ˆéŸµï¼‰","link":"/2025/06/16/poetry/"},{"title":"RGB true-color satellite cloud image","text":"Satellite meteorology course homework, teaching you how to draw a satellite cloud image from scratch.å«æ˜Ÿæ°”è±¡è¯¾ç¨‹å°ä½œä¸šï¼Œæ•™ä½ é›¶åŸºç¡€ç”»å«æ˜Ÿäº‘å›¾ã€‚ å«æ˜Ÿæ°”è±¡è¯¾ç¨‹å°ä½œä¸šåŸæ¥éšä¾¿æ³¨å†Œä¸€ä¸ªè´¦å·ï¼Œå°±å¯ä»¥ç”»å«æ˜Ÿå›¾äº†ã€‚ã€‚ã€‚ä¸‹é¢æ˜¯ä¸€äº›æŒ‡å¯¼ï¼Œä½ éœ€è¦ï¼š1.ç½‘ç«™è´¦å·ï¼Œå¹¶å®Œå–„ç›¸å…³ä¿¡æ¯2.matlab3.å°±è¿™ä¹ˆå¤šä»‹ç»æ€§çš„ä¸æ„Ÿå…´è¶£å°±ç›´æ¥è·³è¿‡å§ Satellite Meteorology Course AssignmentIt used to be that you could register an account and easily draw satellite imagesâ€¦Here are some instructions that you need: 1.Website account and complete relevant information2.Matlab3.Thatâ€™s itIf youâ€™re not interested in the introduction, just skip it. English versionHow to download data:sign in and follow the link: https://ladsweb.modaps.eosdis.nasa.gov/archive/allData/6/MOD021KM Data Introduction:The MODIS Level-1B dataset contains radiance values of 36 discrete spectral bands ranging from 0.4 to 14.4 micrometers, which have been calibrated and geolocated. Channels 1 and 2 have a resolution of 250 meters, channels 3 to 7 have a resolution of 500 meters, and the rest have a resolution of 1 kilometer. It should be noted that the radiance data and associated uncertainties of the 250 and 500-meter bands have been aggregated to a 1-kilometer resolution. A single MODIS 1B data file contains one scene established by 203 scans, sampled 1354 times in the cross-track direction, equivalent to approximately 5 minutes of data. The scene is composed of 1354 by 2030 pixels and covers a spatial range of 2330 kilometers by 2030 kilometers. MOD021KM and MYD021KM are the datasets for the Terra and Aqua satellites, respectively.Analyzing the link above, it is not difficult to find that it points to the data of the Terra satellite, and users can choose the time according to their needs. The data selected in the Matlab code below is MOD021KM.A2019173.0125.061.2019176162129.hdf. Basic Principle:True-color composite refers to the composite color processing of multispectral remote sensing images. If the wavelengths of the three bands involved in the composite are the same or similar to the wavelengths of the corresponding red, green, and blue primaries, the color of the composite image will approximate the true color of the ground objects. Basic Method:Read the reflectance data of 0.46mm, 0.55mm, and 0.64mm of 1km resolution in the MODIS Level-1B dataset.Combine them as red, green, and blue primaries respectively (R = 0.64mm reflectance, G = 0.55mm reflectance, and B = 0.46mm reflectance).Use the three-dimensional vector obtained from step 2) to draw an RGB true-color image. ä¸­æ–‡ç‰ˆæœ¬å¦‚ä½•å¾—åˆ°æ•°æ®:æ³¨å†Œä¸€ä¸ªè´¦å·ï¼Œå¹¶è¿›å…¥ä»¥ä¸‹ç½‘å€: https://ladsweb.modaps.eosdis.nasa.gov/archive/allData/6/MOD021KM æ•°æ®ç®€ä»‹MODIS Level-1Bæ•°æ®é›†åŒ…å«ä½äº0.4å¾®ç±³è‡³14.4å¾®ç±³å…‰è°±åŒºåŸŸçš„36ä¸ªç¦»æ•£æ³¢æ®µçš„è¾å°„å€¼ï¼Œå¹¶è¿›è¡Œäº†æ ¡å‡†å’Œåœ°ç†å®šä½ã€‚å…¶ä¸­ï¼Œé€šé“1å’Œ2çš„åˆ†è¾¨ç‡ä¸º250ç±³ï¼Œé€šé“3è‡³7çš„åˆ†è¾¨ç‡ä¸º500ç±³ï¼Œå…¶ä½™ä¸º1å…¬é‡Œçš„åˆ†è¾¨ç‡ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ250ç±³å’Œ500ç±³æ³¢æ®µçš„è¾å°„åº¦æ•°æ®åŠå…¶ç›¸å…³çš„ä¸ç¡®å®šæ€§å·²ç»æ±‡æ€»åˆ°1å…¬é‡Œåˆ†è¾¨ç‡ã€‚ä¸€ä¸ªå•ä¸€çš„MODIS 1Bçº§æ•°æ®æ–‡ä»¶å°†åŒ…å«ä¸€ä¸ªç”±203æ¬¡æ‰«æå»ºç«‹çš„åœºæ™¯ï¼Œåœ¨äº¤å‰è½¨é“æ–¹å‘ä¸Šé‡‡æ ·1354æ¬¡ï¼Œç›¸å½“äºå¤§çº¦5åˆ†é’Ÿçš„æ•°æ®ã€‚åœºæ™¯å°†ç”±1354ä¹˜ä»¥2030åƒç´ ç»„æˆï¼Œç©ºé—´è¦†ç›–èŒƒå›´ä¸º2330å…¬é‡Œä¹˜2030å…¬é‡Œã€‚MOD021KMã€MYD021KMåˆ†åˆ«æ˜¯Terraå«æ˜Ÿå’ŒAquaå«æ˜Ÿçš„æ•°æ®é›†ã€‚åˆ†æä¸Šé¢çš„é“¾æ¥ä¸éš¾å‘ç°å…¶æŒ‡å‘çš„æ˜¯Terraå«æ˜Ÿçš„æ•°æ®ï¼Œå¤§å®¶å¯ä»¥æ ¹æ®éœ€æ±‚é€‰ç€æ—¶é—´ã€‚åœ¨ä¸‹é¢çš„matlabä»£ç ä¸­é€‰æ‹©çš„æ•°æ®æ˜¯&gt;MOD021KM.A2019173.0125.061.2019176162129.hdf åŸºæœ¬åŸç†çœŸå½©è‰²åˆæˆæ˜¯æŒ‡å¤šå…‰è°±é¥æ„Ÿå›¾åƒå½©è‰²åˆæˆå¤„ç†æ—¶ï¼Œå¦‚æœå‚ä¸åˆæˆçš„ä¸‰ä¸ªæ³¢æ®µçš„æ³¢é•¿ä¸å¯¹åº”çš„çº¢ã€ç»¿ã€è“ä¸‰ç§åŸè‰²çš„æ³¢é•¿ç›¸åŒæˆ–è¿‘ä¼¼ï¼Œé‚£ä¹ˆåˆæˆå›¾åƒçš„é¢œè‰²å°±ä¼šè¿‘ä¼¼äºåœ°é¢æ™¯ç‰©çš„çœŸå®é¢œè‰²çš„ä¸€ç§åˆæˆã€‚ åŸºæœ¬æ–¹æ³•1ï¼‰è¯»å–MODIS Level-1Bæ•°æ®é›†ä¸­ï¼Œ1kmåˆ†è¾¨ç‡çš„0.46mmã€0.55mmã€0.64mmçš„åå°„ç‡æ•°æ®ï¼›2ï¼‰åˆ†åˆ«ç”¨0.64mmã€0.55mmã€0.46mmä½œä¸ºçº¢ç»¿è“ä¸‰åŸè‰²è¿›è¡Œç»„åˆï¼ˆR = 0.64mm reflectance, G = 0.55mm reflectance, and B = 0.46mm reflectanceï¼‰ï¼›3ï¼‰åˆ©ç”¨2ï¼‰ç»„åˆæˆçš„ä¸‰ç»´å‘é‡ç»˜åˆ¶RGBçœŸå½©è‰²å›¾åƒã€‚ ç›¸å…³ä»£ç matlab:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061filename='MOD021KM.A2019173.0125.061.2019176162129.hdf';datdinfo=hdfinfo(filename);EV_250_Aggr1km_RefSB = hdfread(filename, 'EV_250_Aggr1km_RefSB');EV_500_Aggr1km_RefSB = hdfread(filename, 'EV_500_Aggr1km_RefSB');EV_1KM_Emissive = hdfread(filename, 'EV_1KM_Emissive');ref_064=EV_250_Aggr1km_RefSB(1,:,:);ref_064=squeeze(ref_064);ref_064=double(ref_064);info250mv = {datdinfo.Vgroup.Vgroup(2).SDS(5).Attributes.Value};reflectance_scales_250m = double(cell2mat(info250mv(9)));reflectance_offsets_250m = double(cell2mat(info250mv(10)));ref_064=reflectance_scales_250m(1)*(ref_064-reflectance_offsets_250m(1));ref_046=EV_500_Aggr1km_RefSB(1,:,:);ref_046=squeeze(ref_046);ref_046=double(ref_046);info500mv = {datdinfo.Vgroup.Vgroup(2).SDS(8).Attributes.Value};reflectance_scales_500m = double(cell2mat(info500mv(9)));reflectance_offsets_500m = double(cell2mat(info500mv(10)));ref_046=reflectance_scales_500m(1)*(ref_046-reflectance_offsets_500m(1));ref_055=EV_500_Aggr1km_RefSB(2,:,:);ref_055=squeeze(ref_055);ref_055=double(ref_055);ref_055=reflectance_scales_500m(2)*(ref_055-reflectance_offsets_500m(2));lat = hdfread(filename,'Latitude');lon = hdfread(filename,'Longitude');[row, col]= size(ref_055);lon1 = imresize(lon,[row, col]);lat1 = imresize(lat,[row, col]);lon1=double(lon1);lat1=double(lat1);latmin=min(min(lat1));lonmin=min(min(lon1));latmax=max(max(lat1));lonmax=max(max(lon1));ref_064(ref_064&gt;1)=1;ref_064(ref_064&lt;0)=0;ref_064=ref_064.^(0.4);ref_055(ref_055&gt;1)=1;ref_055(ref_055&lt;0)=0;ref_055=ref_055.^(0.4);ref_046(ref_046&gt;1)=1;ref_046(ref_046&lt;0)=0;ref_046=ref_046.^(0.4);rgb_modis(:,:,1)=ref_064; %Redrgb_modis(:,:,2)=ref_055; %greenrgb_modis(:,:,3)=ref_046; %bluehsv_modis=rgb2hsv(rgb_modis);hsv_modis(:,:,2)=hsv_modis(:,:,2)*2;rgb_modis=hsv2rgb(hsv_modis);figureh=axesm ('Frame','on','MapProjection','eqdcylin','FLineWidth',3, 'Grid',... 'on','GColor','k','GLineWidth',1, 'GLineStyle', '--',... 'PLineLocation',5,'MLineLocation',5,'ParallelLabel','on',... 'PLabelLocation', 10,'MLabelLocation', 10,'MeridianLabel','on',... 'MapLatLimit',[latmin latmax],'MapLonLimit',[lonmin lonmax],... 'FontName','Times New Roman','FontSize',12,... 'FontWeight','normal','LabelUnits','degrees');geoshow(lat, lon, rgb_modis);box offset(gca,'Visible','off')print(gcf,'-r300','-dpng',['MOD021KM.A2019173.0125_truecolorRGB.png']); Explanation of CodeHere are some commands that may be useful: To read detailed information of the hdf file: hdfinfoTo read data from hdf file: hdfreadTo convert array to double precision: doubleTo resize an array: imresizeTo draw an image with a map projection: axesm + geoshow For specific function usage, please refer to the help documentation of Matlab. Here are some commands for enhancing the image: When using 0.64mm, 0.55mm, and 0.46mm as the red, green, and blue primary colors for combination, the data for each channel can be adjusted as follows:Limit the data range between 0 and 1;Use the following formula for adjustment: data = data^a (a ~ 0.4); Before drawing the image, use the rgb2hsv function to convert the combined RGB array to the HSV array. After enhancing the saturation, use the hsv2rgb function to convert back to the RGB array (enhancement coefficient b ~ 2).The values of a and b are not fixed and can be experimented with within a reasonable range. ä»£ç ç›¸å…³è¯´æ˜ä¸€äº›å¯èƒ½éœ€è¦çš„å‘½ä»¤ï¼šè¯»å–hdfæ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯ï¼š hdfinfoè¯»å–hdfæ–‡ä»¶ä¸­çš„æ•°æ®ï¼š hdfreadå°†æ•°ç»„è½¬æ¢ä¸ºåŒç²¾åº¦ï¼š doubleè°ƒæ•´æ•°ç»„å¤§å°ï¼š imresizeç»˜åˆ¶åœ°å›¾æŠ•å½±çš„å›¾åƒï¼š axesm + geoshowå…·ä½“çš„å‡½æ•°ä½¿ç”¨ï¼Œå‚è€ƒmatlabçš„helpæ–‡æ¡£ ä¸€äº›ç”¨äºç¾åŒ–å›¾åƒçš„å‘½ä»¤ï¼š1ï¼‰åœ¨åˆ©ç”¨0.64mmã€0.55mmã€0.46mmä½œä¸ºçº¢ç»¿è“ä¸‰åŸè‰²è¿›è¡Œç»„åˆæ—¶ï¼Œå¯¹æ¯ä¸€ä¸ªé€šé“çš„æ•°æ®å¯ä»¥è¿›è¡Œå¦‚ä¸‹ä¿®æ­£ï¼šé™å®šæ•°æ®èŒƒå›´ä¸Šä¸‹é™ä¸º0å’Œ1ï¼›å¯ç”¨å¦‚ä¸‹å…¬å¼è¿›è¡Œä¿®æ­£ï¼šdata = data^a(a~0.4ï¼‰ï¼›2ï¼‰ç»˜å›¾å‰ï¼Œåˆ©ç”¨rgb2hsvå‡½æ•°å°†ç»„åˆæˆçš„RGBæ•°ç»„è½¬åŒ–ä¸ºHSVæ•°ç»„ï¼Œå¢å¼ºé¥±å’Œåº¦ä¹‹åï¼Œå†åˆ©ç”¨hsv2rgbå‡½æ•°è½¬åŒ–å›RGBæ•°ç»„ï¼ˆå¢å¼ºç³»æ•°b ~2ï¼‰ã€‚aï¼Œbæ²¡æœ‰å›ºå®šå€¼ï¼Œå¯ä»¥åœ¨åˆç†èŒƒå›´å†…å°è¯•ã€‚","link":"/2023/05/03/satellite/"}],"tags":[{"name":"thoughts","slug":"thoughts","link":"/tags/thoughts/"},{"name":"strange_life","slug":"strange-life","link":"/tags/strange-life/"},{"name":"literature","slug":"literature","link":"/tags/literature/"},{"name":"as","slug":"as","link":"/tags/as/"}],"categories":[]}